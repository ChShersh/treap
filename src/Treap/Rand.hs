{- | Fair implementation of the 'Treap' data structure that uses random
generator for priorities.
-}

module Treap.Rand
       ( -- * Data structure
         RandTreap (..)

         -- * Smart constructors
       , emptyWithGen
       , oneWithGen
       , empty
       , one

         -- * Interface functions
       , insert
       , delete
       ) where

import GHC.Generics (Generic)
import System.Random (Random (random), StdGen, mkStdGen)

import Treap.Pure (Treap)

import qualified Treap.Pure as Treap

----------------------------------------------------------------------------
-- Data structure and instances
----------------------------------------------------------------------------

{- | Specialized version of 'Treap' where priority has type 'Int' and it's
generated by the stored random generator.
-}
data RandTreap k a = RandTreap
    { randTreapGen  :: !StdGen
    , randTreapTree :: !(Treap k Int a)
    } deriving (Show, Read, Generic, Functor, Foldable, Traversable)

----------------------------------------------------------------------------
-- Smart constructors
----------------------------------------------------------------------------

-- | \( O(1) \). Create empty 'RandTreap' with given random generator.
emptyWithGen :: StdGen -> RandTreap k a
emptyWithGen gen = RandTreap gen Treap.Empty
{-# INLINE emptyWithGen #-}

-- | \( O(1) \). Create empty 'RandTreap' using @mkStdGen 0@.
empty :: RandTreap k a
empty = emptyWithGen (mkStdGen 0)
{-# INLINE empty #-}

-- | \( O(1) \). Create singleton 'RandTreap' with given random generator.
oneWithGen :: StdGen -> k -> a -> RandTreap k a
oneWithGen gen k a =
    let (priority, newGen) = random gen
    in RandTreap newGen $ Treap.one k priority a
{-# INLINE oneWithGen #-}

-- | \( O(1) \). Create singleton 'RandTreap' using @mkStdGen 0@.
one :: k -> a -> RandTreap k a
one = oneWithGen (mkStdGen 0)
{-# INLINE one #-}

----------------------------------------------------------------------------
-- Core functions
----------------------------------------------------------------------------

-- | \( O(\log \ n) \). Insert a value into 'RandTreap' by given key.
insert :: Ord k => k -> a -> RandTreap k a -> RandTreap k a
insert k a (RandTreap gen t) =
    let (priority, newGen) = random gen
    in RandTreap newGen $ Treap.insert k priority a t
{-# INLINE insert #-}

{- | \( O(\log \ n) \). Delete 'RandTreap' node that contains given key. If there is no
such key, 'RandTreap' remains unchanged.
-}
delete :: Ord k => k -> RandTreap k a -> RandTreap k a
delete k (RandTreap gen t) = RandTreap gen $ Treap.delete k t
{-# INLINE delete #-}
